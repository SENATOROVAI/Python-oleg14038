"""
Chapter 4: Python Basics.

This module covers fundamental Python concepts including:
- Variables and Program Structure
- Objects and Type Hierarchy
- Operators and Operations
- Execution Order and Dynamic Typing
"""

import math

numbers = {1, 2, 3}
numbers.add(4)
print(numbers)  # Выведет: {1, 2, 3, 4}

# Удаляет элемент из множества.
numbers.remove(2)
print(numbers)  # Выведет: {1, 3, 4}

# +
# Пример 12: Метод .union()

# Возвращает объединение двух множеств.

set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)
print(union_set)  # Выведет: {1, 2, 3, 4, 5}

# 5. Методы для объектов типа file
#
# Python поддерживает работу с файлами. Примеры методов для работы с файлами:

# Пример 13: Метод .read()

# Чтение содержимого файла.

# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)

# +
# Пример 14: Метод .write()

# Запись данных в файл.

# with open('example.txt', 'w') as file:
#     file.write("Hello, world!")

# +
# Пример 15: Метод .close()

# Закрытие файла (автоматически вызывается при использовании with)

# file = open('example.txt', 'r')
# file.close()

# Встроенные методы
# На самом деле это то же самое, что и встроенные функции. Метод в Python по
# хож на функцию, за исключением того, что он относится к объекту. Вызывая
# метод объекта, мы, вероятно, вносим в этот объект изменения. Таким образом,
# метод принадлежит классу. Примером является метод добавления элемента
# в список append ( )

# В Python существует множество встроенных функций и методов, которые можно использовать без необходимости их импорта. Они предоставляют базовую функциональность для выполнения различных операций. Вот некоторые из наиболее часто используемых встроенных методов с примерами.

# 1. len()

# Возвращает длину (количество элементов) объекта (например,
#  строки, списка, кортежа, словаря).

# Пример с строкой
text = "Hello"
print(len(text))  # Выведет: 5

# Пример со списком
num = [1, 2, 3, 4, 5]
print(len(num))  # Выведет: 5

# 2. abs()

# Возвращает абсолютное значение числа.

value = -10
print(abs(value))  # Выведет: 10

# 3. sum()

# Возвращает сумму элементов итерируемого
# объекта (например, список или кортеж).

coun = [1, 2, 3, 4, 5]
print(sum(coun))  # Выведет: 15


# 4. min() и max()

# Возвращают минимальное и максимальное значение
# из последовательности или набора чисел

print(min(coun))  # Выведет: 1
print(max(coun))  # Выведет: 9

# 4. min() и max()

# Возвращают минимальное и максимальное
# значение из последовательности или набора чисел.

# +
# 5. round()

# Округляет число до заданного количества
# знаков после запятой (по умолчанию до ближайшего целого).

constant_value = 3.14159
print(round(constant_value, 2))  # Выведет: 3.14

# Округление до ближайшего целого
# print(round(5.6))  # Выведет: 6

# 6. type()

# Возвращает тип объекта.

obj = 42
print(type(obj))  # Выведет: <class 'int'>

text_three = "Hello"
print(type(text_three))  # Выведет: <class 'str'>

# 7. isinstance()

# Проверяет, принадлежит ли объект
# к определённому типу данных

print(isinstance(obj, int))  # Выведет: True
print(isinstance(text_three, str))  # Выведет: True

# +
# 8. enumerate()

# Возвращает объект, который генерирует кортежи,
# содержащие индекс и соответствующий элемент последовательности.

fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# Выведет:
# 0: apple
# 1: banana
# 2: cherry

# +
# 9. zip()

# Объединяет несколько итерируемых объектов (например, списки)
# в кортежи, где первый элемент каждого кортежа будет взят
# из соответствующего итерируемого объекта.

names = ["Alice", "Bob", "Charlie"]
scores = [85, 90, 95]

for name, score in zip(names, scores):
    print(f"{names}: {score}")

# Выведет:
# Alice: 85
# Bob: 90
# Charlie: 95

# +
# 10. sorted()

# Возвращает отсортированную версию итерируемого объекта
# (например, список), не изменяя оригинал.

numbers_val = [5, 2, 9, 1, 5, 6]
sorted_numbers = sorted(numbers_val)
print(sorted_numbers)  # Выведет: [1, 2, 5, 5, 6, 9]

# Оригинальный список не изменён
print(numbers_val)  # Выведет: [5, 2, 9, 1, 5, 6]
# -

# 11. all() и any()
#
#     all() возвращает True, если все элементы итерируемого объекта истинные.
#
#
#     any() возвращает True, если хотя бы один элемент итерируемого объекта истинный.

# +
# # Пример с all()
# print(all([True, True, False]))  # Выведет: False

# # Пример с any()
# print(any([False, False, True]))  # Выведет: True

# +
# 13. filter()

# Фильтрует элементы итерируемого объекта на основе функции,
# которая возвращает True или False.

numbers_one = [1, 2, 3, 4, 5, 6]

# Оставляем только чётные числа
even_numbers = filter(lambda x: x % 2 == 0, numbers_one)
print(list(even_numbers))  # Выведет: [2, 4, 6]

# +
# # 15. eval()

# # Выполняет строковое выражение как Python-код.
# # Будьте осторожны при использовании eval(),
# # так как оно может быть небезопасным

# expression = "2 + 3 * 5"
# result_3 = eval(expression)
# print(result_3)  # Выведет: 17

# +
# # 16. open()

# # Открывает файл для чтения или записи.

# # Открываем файл для записи
# with open('example.txt', 'w') as file:
#     file.write("Hello, World!")

# # Открываем файл для чтения
# with open('example.txt', 'r') as file:
#     content = file.read()
#     print(content)  # Выведет: Hello, World!
# -

# ♦ Классы
# Классы относятся к вызываемым объектам и объединяют в себе данные и функ
# циональность. Создание нового класса позволяет создать новый тип объектов, а
# в дальнейшем и новые экземпляры этого типа. Каждый экземпляр класса ханит
# атрибуты, определяющие его состояние. Экземпляр класса также может иметь
# методы (определяемые этим классом), изменяющие его состояние.

# Классы в Python — это конструкции, позволяющие создавать пользовательские объекты, которые могут содержать как данные (атрибуты), так и функции (методы). Они позволяют организовать код и облегчить его повторное использование.

# +
# 1. Простой класс
# Пример 1: Класс Dog


class Dog:
    """Класс для представления собак."""

    def __init__(self, name_dog: str, age_dog: int):
        """Инициализация атрибутов собаки."""
        self.name_dog: str = name_dog
        self.age_dog: int = age_dog

    def bark(self) -> str:
        """Издает лай."""
        return f"{self.name_dog} говорит: Гав!"


# Создание экземпляра класса
my_dog = Dog("Бобик", 3)

# Вызов метода
print(my_dog.bark())  # Выведет: Бобик говорит: Гав!

# +
# Пример 2: Класс Circle


class Circle:
    """Класс для представления круга."""

    def __init__(self, radius: float):
        """Инициализация радиуса круга."""
        self.radius: float = radius

    def area(self) -> float:
        """Возвращает площадь круга."""
        result: float = float(math.pi * (self.radius**2))
        return result

    def circumference(self) -> float:
        """Возвращает длину окружности."""
        result: float = float(2 * math.pi * self.radius)
        return result


# Создание экземпляра класса
circle = Circle(10)

# Вызов методов
print(f"Площадь круга: {circle.area():.2f}")  # Выведет: Площадь круга: 78.54
print(
    f"Длина окружности: {circle.circumference():.2f}",
)  # Выведет: Длина окружности: 31.42
# -

# 4.4.7. Модули
# В целом модуль - это то же самое, что и библиотека кода, т. е. файл с набором
# функций, которые вы хотите добавить в свое приложение. Чтобы создать модуль,
# достаточно лишь сохранить нужный код в файле с расширением ру.
# После этого вновь созданный модуль можно импортировать с помощью оператора
# import.
# Модуль может содержать функции, а также переменные всех типов (массивы, сло
# вари и т. д.)

# 4.5. Операции с объектами в Python

# +
# 14 + 26 # целочисленное сложение

# +
# 1.5 * 4 # умножение вещественных чисел

# +
# 2**100 # 2 в степени 100

# +
# 4/2 # деление всегда возвращает число с плавающей точкой

# +
# 5 > 4 # логическое выражение
# -

# 4.6. Операторы 1
#
# 4.6.1 . Арифмети ческие операторы
# Оператор Операция
# + Сложение
#
# - Вычитание
#
# * Умножение
#
# / Деление
#
# % Остаток от деления
#
# // Целочисленное деление
#
# ** Возведение в степень

# ♦ + (плюс)
# Складывает два объекта.
# • 4 + 3 дает 7.
# • , а , + , Ь , дает ' аЬ ' .
#
# ♦ - (минус)
# Выполняет вычитание одного числа из другого. Если первый операнд отсутст
# вует, предполагается, что он равен нулю.
# • -2 . в дает отрицательное число.
# • 70 - 34 дает 36.
#
# ♦ * (умножение)
# Возвращает произведение двух чисел или повторяет строку заданное число раз.
# • 2 * 3 дает 6.
# • 'ля ' * 3 дает ' ляляля ' .
#
# ♦ ** (степень)
# • х ** у возвращает х в степени у.
# • 2 ** 3 возвращает в.
# ♦ / (деление)
# • х / у делит число х на число у.
# • 13 / 3 дает 4 , 333333333333333
#
# // (целочисленное деление)
# х / / у делит х на у и округляет ответ до ближайшего целого числа. При этом,
# если одно из чисел является дробным, ответ тоже будет числом с плавающей
# точкой.
# • 1 з / / з дает 4 .
# • - 1 з // з дает -5.
# • 9 // 1 . в1 дает 4 . О.
#
# ♦ % (остаток от деления)
# Возвращает остаток от деления.
# • 1 3 % з дает 1 .
# • -25 . 5 % 2 . 25 дает 1 . 5

# 4.6.3. Операторы сравнения
# Оператор Операция
# - Равенство
# !=  Неравенство
#
# > Больше
#
# < Меньше
#
# >= Больше или равно
#
# <= Меньше или равно

# ♦ == (равно)
# Проверяет равенство объектов. Например:
# • х = 2; у = 2 ; х == у возвращает True.
#
# • х = ' str ' ; у = ' stR ' ; х == у возвращает False.
#
# • х = ' str ' ; у = ' str ' ; х == у возвращает True.

# ♦ ! = (не равно)
# Проверяет неравенство объектов. Например:
# х = 2; у = 3; х ! = у возвращает True

# ♦ < (меньше)
# х < у проверяет, действительно ли х меньше у. Как и все прочие операторы срав
# нения, возвращает True или False.
# 6 < 4 дает False, а 4 < 6 дает True.
#
# Сравнения можно соединять в цепочки: например, 3 < 5 < 7 дает тrue

# ♦ > (больше)
# х > у проверяет, действительно ли х больше у.
# 6 > 4 возвращает True. Если оба операнда являются числами, они сначала приво
# дятся к общему типу. В противном случае всегда возвращает False

# ♦ <= (меньше или равно)
# х <= у проверяет, действительно ли х меньше или равно у.
# х = 3; у = 6; х <= у возвращает True

# ♦ >= (больше или равно)
#
# х >= у проверяет, действительно ли х больше или равно у.
#
# х = 4 ; у = 3 ; х > = 3 возвращает True

# 4.6.4. Логи ческие операторы

# ♦ not (логическое НЕ)
#
# • Если х равен True, возвращает False.
#
# • Если х равен False, возвращает тrue.
#
# ♦ and (логическое И)
#
# • х and у возвращают значение False, если х равно False, в противном случае
# возвращается значение у.
#
# • Пусть х = False ; у = True. Тогда х and у возвращают False, поскольку х имеет
# значение False. В этом случае Python не будет вычислять значение у, по
# скольку знает, что левая часть выражения and имеет значение False, и поэтому
# все выражение будет равно False независимоо от другх значений. Эrо назы
# вается сокращенной оценкой логического выражения

# or (логическое ИЛИ)
#
# • Если х равен тrue, возвращает True, иначе возвращает оценку у.
#
# • Пусть х = тrue; у = False. Тогда х or у возвращает True. Здесь также может
# выполняться сокращенная оценка.

# 4.6.5. Операторы идентификации и вхождения

# Оператор Выражение
# Операторы идентификации
#
# is       х is у
#
# is      not х is not у
#
# Операторы вхождения
#
# in         х in у
#
# not in     х not in у

# +
z_num = [1, 2, 3]
b_number = z_num  # b ссылается на тот же объект, что и a

print(
    z_num is b_number,
)  # True, так как обе переменные ссылаются на один и тот же объект
# -

# ♦ Операторы идентификации проверяют идентичность двух объектов.
# • is
#
# Если если х - это тот же объект, что и у,
#
# выражение возвращает True.  противном
# случае возвращается False

# • is not
#
#
#
# Если х не является тем же объектом, что и у,
#
# выражение возвращает True.
#
# В противном случае возвращается False.

# Операторы вхождении проверяют, является ли данный объект элементом дан
# ной коллекции.
#
# Под «коллекцией» понимается последовательность или структу
# ра данных, например строка, список, кортеж и т. д.

# • in
# Если х является элементом коллекции у, то возвращается тrue, в противном
# случае возвращается False.
#
# • not in
# Если х не является элементом коллекции у, возвращается True, в противном
# слчае возвращается False.

# +
# Строка
word = "hello"

print("h" in word)  # True, так как "h" есть в строке
# -

# 4.9. Порядок выполнения
# Порядок вычисления в математическом уравнении вам наверняка известен со шко
# лы: сначала скобки, затем степень, деление, умножение, сложение и вычитание, в
# порядке слева направо.

# Операторы выражений в круглых скобках: ()
# Используются для группировки операций и повышения приоритета.

# Оператор возведения в степень: **
# Выполняется справа налево.
#
# 2 ** 3 ** 2  # 2 ** (3 ** 2) = 512
#

# Унарные операторы: +, -, ~
# Применяются к одному операнду.
#
# -5  # Отрицательное значение
#

# Операторы умножения, деления, деления с округлением, остатка:
#
# *, /, //, %
#
# 10 * 2  # Умножение
#
# 10 / 3  # Обычное деление
#
# 10 // 3  # Целочисленное деление
#
# 10 % 3  # Остаток от деления
#

# Операторы сложения и вычитания: +, -
#
# 5 + 3  # Сложение
#
# 5 - 3  # Вычитание
#

# Операторы сдвига: <<, >>
#
# 1 << 2  # Сдвиг влево на 2 бита
#
# 8 >> 2  # Сдвиг вправо на 2 бита
#

# Операторы побитового "И": &
#
# 5 & 3  # Побитовое "И"
#

# Операторы побитового
#
# "Исключающего ИЛИ" (XOR) и побитового "ИЛИ": ^, |
#
# 5 ^ 3  # Побитовое исключающее "ИЛИ"
#
# 5 | 3  # Побитовое "ИЛИ"
#

# Операторы сравнений: ==,
# !=,
#
# >,
#
# >=,
#
# <,
#
# <=,
#
# is,
#
# is not,
#
# in,
#
# not in
#
# 5 == 5  # Равно
#
# 5 != 3  # Не равно
#
# 5 > 3   # Больше
#

# Оператор логического "НЕ": not
#
# not True  # Логическое отрицание
#

# Оператор логического "И": and
#
# True and False  # Логическое "И"
#

# Оператор логического "ИЛИ": or
#
# True or False  # Логическое "ИЛИ"
#

# Оператор присваивания: =, а также присваивание с операцией: +=, -=, *=, /=, //=, %=, **=, &=, |=, ^=, >>=, <<=
#
# x = 5  # Присваивание
#
# x += 2  # Сложение с присваиванием
#

# Оператор условного выражения: if ... else
#
# x = 5 if condition else 10  # Условное выражение
#

# Операторы лямбда-выражений: lambda
#
# f = lambda x: x + 2  # Лямбда-функция
#

# Операторы с более высоким приоритетом выполняются раньше.
#
# Круглые скобки позволяют явно управлять порядком операций.

# 4.9.2. Ассоциативность
#
# Операторы с одинаковым приоритетом вычисляются слева направо. Например, запись
#
# 2 + 3 + 4 эквивалентна ( 2 + 3 ) + 4 . Исключение составляет только оператор
#
# возведения в степень ** - он имеет ассоциативность справа налево.

# 4.9.3. Площадь прямоугольника

Length = 5
Width = 8
Area = Length * Width
print("Area of the Rectangle is", Area)
print(" Perimeter of the rectangle is", 2 * (Length + Width))

# 4. 1 О. Дина м и ческая тип изация
#
# В Python значение, на которое указывает переменная, имеет определенный тип
#
# данных, но сама переменная не имеет строгого типа. Вы можете повторно исполь
#
# зовать одну и ту же переменную, передавая ей ссьmку на объект уже другого типа.
#
# Переменные можно считать «ярлыками», связанными с объектами.
#
# six = 6
# six
#
# six = ' six '
#
# six

# 4.1 2. Логи ческая и физическая строка
#
# Физическая строка кода - это то, что вы буквально видите на экране, когда пише
# те программу.
#
# Логическая строка - это то, что Python считает единым выпол
# няемым выражением.
#
# Python неявно предполагает, что каждая физическая строка
# соответствует логической строке.
#
#

# эдесь две физические и две логические строки
i_number = 5
print(i_number)

# Здесь оператор i = 5 - это и физическая, и логическая строка. И функция
# print (i) - это тоже и физическая, и логическая строка.

# эдесь одна физическая строка, но две логические
i_one = 5
print(i_one)

# Python видит здесь две разные строки (логические строки), а вы, как программист,видите одну физическую строку.
#
# И зачем нам это?
#
# Если вы хотите записать более одной логической строки на одной физической
# строке, вы должны использовать точку с запятой (; ), которая отмечает конец логи
# ческой строки/оператора.
